# 3.2 程序编码

#### 编译指令(假设两个编译文件 p1.c 和p2.c)：

```
linux> gcc -Og -o p p1.c p2.c
```

#### 指令解释：&#x20;

gcc：指的是 GCC C编译器。也可用 cc 来启动它。

编译选项 -Og：向编译器指定使用符合原始C代码整体结构的优化级别 ，使用这个优化级别是为了利于更容易理解产生的机器代码和源代码的关系。实际中会使用更高的优化级别来提高性能，如-O1 或 -O2。

命令行指示符 -o、编译过程：指定生成最终的可执行代码文件，可执行文件的名字可以紧跟在 -o 指示符后面。实际上可以用不同的指示符是编译过程进程进行到不同的阶段（分段编译）。完整的编译过程是 ：        &#x20;

&#x20;     首先：_**预处理器**_工作，处理#include和#define等内容。

&#x20;     之后：_**编译器**_产生原文件对应的汇编代码文件，如p1.s   p2.s。对应编译选项：-S 。

&#x20;     接下来：_**汇编器**_将汇编代码转化成二进制目标代码文件，如 p1.o p2.o。对应编译选项：-c 。

&#x20;     最后：_**链接器**_将目标代码文件、实现库函数的代码合并，产生最终的可执行文件。

通过指定不同的命令行指示符（如-s），可以进行_**分阶段编译**_，也可用利用CMAKE实现自动构建。更详细的介绍如CMAKE、程序库等可参考以下链接，写的很好：

{% embed url="https://linux.fasionchan.com/zh_CN/latest/development-environment/c-cpp.html" %}
链接里写的简单明了，大大滴好！
{% endembed %}

### 机器级代码

对于机器级编程来说，两种抽象尤为重要：

1. _指令集体系结构_，或指_令集架构，_定义了机器级程序的格式和行为。大多数ISA（包括x86-64），将程序的行为描述成好像每条指令都是按顺序执行的。实际上，处理器的硬件远比描述的精细复杂，他们并发的执行多条指令，但是运行的整体行为和ISA指定顺序执行的行为一致。
2. 机器级程序使用的内存地址为虚拟地址，内存模型看上去像一个非常大的字节数组，实际上是多个硬件存储器和操作系统软件组合起来。

机器代码中一些可见的处理器状态：

* 程序计数器：通常成为“PC”，给出将执行的下一条指令在内存中的地址。
* 整数寄存器文件：16个64位寄存器，可以存储地址或整数数据。有的保存某些程序状态，有的保存临时数据。
* 条件码寄存器：保存最近执行的算术或逻辑指令的状态信息。可用来实现控制或数据流中的条件变化，如if、while。
* 向量寄存器：存放一个或多个整数或浮点数值。
